# Type Inference

## Agenda

- Inference by Example
- Type Variables and Constraints
- Constrained Typing Judgments
- Monomorphic Type Inference
- Solving Constraints with Unification
- Polymorphic Type Inference

## Inference by Example

How can we infer their types?

- `fun x -> x`

- `fun x -> x + 1`

- `fun f -> fun x -> f x`

- `fun f -> fun x -> f (f x)`

<!--
fun x -> x
- raw type: 'a -> 'a
- no constraints/substitution
- final type: 'a -> 'a

fun x -> x + 1
- raw type: 'a -> int
- gathered constraints { 'a=int,
                        int=int }
- computed substitution { 'a |-> int }
- final type: int -> int

fun f -> fun x -> f x
- raw type: 'a -> 'b -> 'c
- gathered constraints { 'a = 'b -> 'c }
- computed substitution { 'a |-> 'b -> 'c }
- final type: ('b -> 'c) -> 'b -> 'c

fun f -> fun x -> f (f x)
- raw type: 'a -> 'b -> 'c
- gathered constraints { 'a = 'b -> 'd,
                        'a = 'd -> 'c }
- computed substitution { 'a |-> 'c -> 'c,
                         'b |-> 'c,
                         'd |-> 'c  }
- final type: ('c -> 'c) -> 'c -> 'c
-->

## From Examples to Mechanism

To infer types, we:

1. Create *type variables* to represent unknowns
2. Collect *constraints* over those variables
3. *Solve* those constraints to obtain a substitution
4. Apply the *substitution* to get the final inferred type

Intuitively, we do ...

1. Going "up" the proof tree
2. Going "down" the proof tree; this is the tree's "output"
3. This is the unification algorithm, which we'll cover later

- if it fails, the expression is ill-typed!

4. We apply substitution to the raw type from the tree

## Type Variables

Type variables are placeholders for unknown types

- May be replaced with other types when solving constraints

- May remain in a final inferred type for polymorphism

We expand our spectrum of types:

```ocaml
type typ = TInt
         | TBool
         | TFun of typ * typ
         | TVar of type_var
```

## Creating "Fresh" Type Variables

New type variables must be *fresh* -- i.e., they cannot be used/constrained elsewhere in the environment. (Why?)

Our implementation simply makes `type_var`s sequential `int`s.

```ocaml
type type_var = int

let fresh_int =
  let counter = ref 0 in
  fun () ->
    let v = !counter in
    incr counter;
    v

let fresh_var () = TVar (fresh_int ())
```

So, `TVar 0` = `…ë`, `TVar 1` = `Œ≤`, `TVar 2` = `…£`, ...

## Constraints

A constraint is an equation between types.

E.g., `bool` = `bool`; `…ë` = `int`; `Œ≤‚Üí int` = `bool‚Üí …£`

We can represent this as:

```ocaml
type type_constraint = typ * typ
```

## Constrained Typing Judgments

We update our typing judgment to:

```typst +render +width:40%
#let tstile = sym.tack.r
#let rtstile = sym.tack.l
$
Gamma tstile e : tau rtstile C
$
```

I.e., `e` has type `œÑ` under `Œì` iff all constraints in `C` are satisfiable.

## Collecting Constraints

Our first goal is to recursively collect constraints for an expression:

```ocaml
val collect_constraints :
  type_env -> expr -> typ * type_constraint list
```

## Type Inference Rules

### Values

```typst +render +width:60%
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
"INT" & () / (Gamma tstile i in ZZ : "int" rtstile {}) \
     \
"BOOL" & () / (Gamma tstile b in {"true", "false"} : "bool" rtstile {}) \
$
```

No constraints are generated by these rules.

```ocaml
let rec collect_constraints tenv e =
  match e with
  | Int _ ->  (TInt, [])
  | Bool _ -> (TBool, [])
```

### Variables

```typst +render +width:30%
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
"VAR" & (Gamma(x) = tau) / (Gamma tstile x : tau rtstile {})
$
```

```ocaml
| Var x -> (lookup tenv x, [])
```

### Binary Operators

```typst +render +width:80%
#let bop = sym.plus.o
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
 "BOP-I" & (bop in {+,*}
           quad Gamma tstile e_1 : tau_1 rtstile C_1
           quad Gamma tstile e_2 : tau_2 rtstile C_2)
           / (Gamma tstile e_1 bop e_2 : "int"
           rtstile C_1 union C_2
           union { tau_1 = "int", tau_2 = "int"}) \
         \
 "BOP-B" & (quad Gamma tstile e_1 : tau_1 rtstile C_1
           quad Gamma tstile e_2 : tau_2 rtstile C_2)
           / (Gamma tstile e_1 <= e_2 : "bool"
           rtstile C_1 union C_2
           union { tau_1 = "int", tau_2 = "int"}) \
$
```

The `BOP` rules constrain their operands to be of type `int`.

```ocaml
| Binop (bop, e1, e2) -> (
    let t1, c1 = collect_constraints tenv e1 in
    let t2, c2 = collect_constraints tenv e2 in
    match bop with
    | Add | Mult ->
        (TInt, c1 @ c2 @ [ (t1, TInt); (t2, TInt) ])
    | Leq ->
        (TBool, c1 @ c2 @ [ (t1, TInt); (t2, TInt) ]))
```

### `if-then-else`

```typst +render +width:100%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "IF" & ("fresh" alpha
         quad Gamma tstile e_1 : tau_1 rtstile C_1
         quad Gamma tstile e_2 : tau_2 rtstile C_2
         quad Gamma tstile e_3 : tau_3 rtstile C_3)
         / (Gamma tstile "if" e_1 "then" e_2 "else" e_3 : alpha
         rtstile C_1 union C_2 union C_3
         union { tau_1 = "bool", alpha=tau_2, alpha=tau_3}) \
$
```

```ocaml
| If (e1, e2, e3) ->
    let t = fresh_var () in
    let t1, c1 = collect_constraints tenv e1 in
    let t2, c2 = collect_constraints tenv e2 in
    let t3, c3 = collect_constraints tenv e3 in
    (t, c1 @ c2 @ c3 @ [ (t1, TBool); (t, t2); (t, t3) ])
```

## Demo

```ocaml
dune utop
# L10_typeinfer.Mono_typeinfer.repl ();;
```

What constraints do the following generate?

- `1 + 2`
- `1 + true`
- `if 1 then 2 else 3`
- `if 1 <= true then 2 else false`

### `let`

```typst +render +width:80%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "LET" & (
          Gamma tstile e_1 : tau_1 rtstile C_1
          quad
          Gamma[x mapto tau_1] tstile e_2 : tau_2 rtstile C_2
          )/(
          Gamma tstile "let" x = e_1 "in" e_2 : tau_2 rtstile C_1 union C_2
          )
$
```

```ocaml
| Let (x, e1, e2) ->
    let t1, c1 = collect_constraints tenv e1 in
    let tenv' = (x, t1) :: tenv in
    let t2, c2 = collect_constraints tenv' e2 in
    (t2, c1 @ c2)
```

### `fun`

```typst +render +width:70%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
   "FUN" & ("fresh" alpha
           quad Gamma[x mapto alpha] tstile e : tau rtstile C)
           / (Gamma tstile "fun" x "->" e : alpha -> tau
           rtstile C) \
$
```

```ocaml
| Fun (x, e) ->
    let tx = fresh_var () in
    let tenv' = (x, tx) :: tenv in
    let te, ce = collect_constraints tenv' e in
    (TFun (tx, te), ce)
```

### Application

```typst +render +width:80%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
 "APP" & ("fresh" alpha
         quad Gamma tstile e_1 : tau_1 rtstile C_1
         quad Gamma tstile e_2 : tau_2 rtstile C_2)
         / (Gamma tstile e_1 e_2 : alpha rtstile C_1 union C_2
         union { tau_1 = tau_2 -> alpha})
$
```

```ocaml
| App (e1, e2) ->
    let t = fresh_var () in
    let t1, c1 = collect_constraints tenv e1 in
    let t2, c2 = collect_constraints tenv e2 in
    (t, c1 @ c2 @ [ (t1, TFun (t2, t)) ])
```

## Demo

```ocaml
dune utop
# L10_typeinfer.Mono_typeinfer.repl ();;
```

What constraints do the following generate?

- `fun x -> x`
- `fun x -> x + 1`
- `fun f -> fun x -> f x`
- `(fun x -> x) 10`

## Solving Constraints

Goal: find a *substitution* `S` where `S`(`œÑ‚ÇÅ`) = `S`(`œÑ‚ÇÇ`) for all constraints `œÑ‚ÇÅ` = `œÑ‚ÇÇ`.

- Where a substitution maps type variables to types

  - i.e., `S` = { `Œ±‚ÇÅ ‚Ü¶ œÑ‚ÇÅ`, `…ë‚ÇÇ ‚Ü¶ œÑ‚ÇÇ`, ... }

- Applying substitution `S` to type `œÑ` (i.e., `S`(`œÑ`)) replaces type variables in `œÑ` based on the mappings

  - e.g., given `S` = { `…ë ‚Ü¶ int`, `Œ≤ ‚Ü¶ bool` }

    - `S`(`…ë ‚Üí  Œ≤`) = `int ‚Üí bool`

**Unification** is an algorithm that solves this problem.

## Unification Rules

1. `Unify`(`œÑ`, `œÑ`) = {}

2. `Unify`(`Œ±`, `œÑ`) or `Unify`(`œÑ`, `Œ±`) = { `Œ± ‚Ü¶ œÑ` } if `Œ±` ‚àâ `œÑ`

   - if `Œ±` ‚àà `œÑ`, "infinite type" failure (why?)

3. `Unify`(`œÑ1 ‚Üí œÑ2`, `œÑ3 ‚Üí œÑ4`) = `S2` ‚àò `S1`

   - where `S1` = `Unify`(`œÑ1`, `œÑ3`)

   - and `S2` = `Unify`(`S1`(`œÑ2`), `S1`(`œÑ4`))

4. Otherwise: incompatible types failure

The test that `Œ±` ‚àâ `œÑ` is known as an "occurs test"

- e.g., see the constraint Œ± = Œ± -> int

Rule 3 introduces the idea of *composing* substitutions

## Applying Unification

To solve a list of constraints {`œÑ‚ÇÅ` = `œÑ‚ÇÇ`, ... },

1. Unify each in turn, producing a substitution `S`

2. Apply `S` to remaining constraints and the accumulated substitution

3. Continue until all constraints are processed or failure

If unification completes, it yields the *most general unifier* (*MGU*): the substitution that solves all constraints without being overly specific.

- Intuition: `fun x -> x` should have type `Œ± ‚Üí Œ±`, not `int ‚Üí int`

## Sample Unification Problems

Find the MGU for each constraint set, or explain why unification fails.

(1)

`…ë` = `bool`

`Œ≤` = `…ë`

(4)

`…ë` ‚Üí `Œ≤` = `bool` ‚Üí `int`

`…ë` = `int`

(2)

`…ë` ‚Üí `int` = `bool` ‚Üí `Œ≤`

(5)

`…ë` = `Œ≤` ‚Üí `…£`

`Œ≤` = `…£` ‚Üí `int`

`…ë` = `ùõÖ` ‚Üí `Œµ`

(3)

`…ë` = `Œ≤` ‚Üí `…£`

`…ë` = `int` ‚Üí `bool`

(6)

`…ë` = `Œ≤` ‚Üí `int`

`Œ≤` = `…ë`

<!--
Remember that you can check your substitutions by applying them to the
constraints!

Solutions:
(1) { 'a |-> bool, 'b |-> bool }

(2) { 'a |-> bool, 'b |-> int }

(3) { 'a |-> int -> bool,
     'b |-> int,
     'c |-> bool }

(4) type mismatch failure (bool = int)

(5) { 'a |-> ('e -> int) -> 'e,
     'b |-> 'e -> int,
     'd |-> 'e -> int,
     'c |-> 'e }

(6) infinite type failure
-->

## Implementing Unification

```ocaml
type substitution = (type_var * typ) list

let rec unify (t1 : typ) (t2 : typ) : substitution =
  match (t1, t2) with
  | TInt, TInt   -> []
  | TBool, TBool -> []
  | TVar v, ty | ty, TVar v ->
      [ (v, ty) ] (* check for infinite type *)
  | TFun (a1, b1), TFun (a2, b2) ->
      let s1 = unify a1 a2 in
      let b1' = apply_subst s1 b1 in
      let b2' = apply_subst s1 b2 in
      let s2 = unify b1' b2' in
      compose_subst s2 s1
  | _ -> raise (TypeError "Incompatible types")
```

```ocaml
let solve_constraints constraints =
  List.fold_left
    (fun subst (lhs, rhs) ->
      let lhs' = apply_subst subst lhs in
      let rhs' = apply_subst subst rhs in
      let new_subst = unify lhs' rhs' in
      compose_subst new_subst subst)
    empty_subst constraints
```

To run the REPL with automated unification of constraints on, do:

```
> dune utop
# L10_typeinfer.Mono_typeinfer.repl ~solve:true ();;
```

## Beyond Type Inference: Unification

Unification is a *general mechanism for solving symbolic equations*.

Broad application -- at the crossroads of *logic*, *algebra*, *programming languages*, and *AI*!

- Logic programming / Automated reasoning (e.g., Prolog)

- Theorem proving and Constraint solvers

- Term rewriting and Symbolic computation

- Linguistics: unification grammars

- AI: rule-based systems and ontology reasoning

Historical and Conceptual Timeline of Unification

- 1930s ‚Äì Foundations: Early work in mathematical logic by Jacques Herbrand and others on symbolic substitution in first-order logic laid the groundwork for reasoning about equality between terms.

- 1965 ‚Äì Automated Reasoning: J. Alan Robinson introduced unification in his *resolution principle* for first-order logic, making it the key step in automated theorem proving. Two formulas can be resolved if their predicates can be unified, i.e., made identical under some substitution.

- 1970s ‚Äì Logic Programming: The creators of *Prolog* took unification from theorem proving and made it the engine of execution. When Prolog answers a query, it repeatedly performs unification between the query and program clauses, instantiating variables as it goes.

- 1978 ‚Äì Type Systems: Robin Milner applied the same idea to **type inference**. Instead of unifying logical terms, his algorithm unified *type expressions*, allowing a compiler to infer the most general type of an expression automatically. This became the basis of the **Hindley‚ÄìMilner type system**, used in ML, OCaml, and Haskell.

- 1980s‚ÄìPresent ‚Äì Constraint Solvers and Beyond: Unification was generalized to constraint solving and symbolic reasoning. Modern SMT solvers (like Z3 and CVC5), theorem provers, and term-rewriting systems all rely on variants of unification to reconcile symbolic structures under constraints.

- Today ‚Äì Across Disciplines: Unification remains a central idea not only in type systems, logic, and AI, but also in natural-language processing (unification-based grammars), symbolic algebra systems, and formal verification.

**Takeaway:** What began as a logic technique for proving theorems evolved into a universal mechanism for *symbolic constraint solving*. Whether the "symbols" are logical predicates, program types, linguistic features, or algebraic expressions, unification is the tool that finds consistent substitutions to make structures agree.

## The Problem with Let

What types do we infer for the following?

```ocaml
let id = fun x -> x in id

let id = fun x -> x in id 10

let id = fun x -> x in let a = id 10 in id

let id = fun x -> x in let a = id 10 in id true
```

## Monomorphic vs. Polymorphic Type Systems

Thus far, a type variable has acted as an *existential placeholder*

- e.g., in `id : Œ± -> Œ±`, `Œ±` means *some (single) unknown type*

- Once we apply the function to a concrete type, it is fixed

- `Œì` maps variables to *monotypes*; the system is *monomorphic*

Polymorphism must allow a type variable to mean *any type*

- e.g., so `id 42` (`Œ±` = `int`) and `id true` (`Œ±` = `bool`) can coexist

- Type variables should be *universally quantified*

## Mechanism: *Type Scheme*

A **type scheme** explicitly quantifies type variables in a type.

```typst +render +width:40%
$
pi = forall alpha_1, ..., alpha_n . tau
$
```

E.g., for `id`, we have the type scheme:

```typst +render +width:30%
$
 "id" : forall alpha . alpha -> alpha
$
```

## Updating Œì with Type Schemes

In a polymorphic type system, `Œì` maps variables to type schemes.

```ocaml
type type_scheme = Forall of type_var list * typ

type type_env = (string * type_scheme) list

let lookup (env : type_env) (name : string) : type_scheme =
  match List.assoc_opt name env with
  | Some scheme -> scheme
  | None -> raise (TypeError "Unbound variable")
```

## Let-Generalization

To support polymorphism via a `let x=e‚ÇÅ in e‚ÇÇ` expression:

1. Infer a monotype `œÑ‚ÇÅ` for `e‚ÇÅ`

2. *Generalize* a type scheme `œÄ‚ÇÅ` from `œÑ‚ÇÅ`

   - Quantify type vars that aren't free in the environment

3. Evaluate `e‚ÇÇ` in the environment extended with `x: œÄ‚ÇÅ`

```typst +render +width:100%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "LET" & (
          Gamma tstile e_1 : tau_1 rtstile C_1
          quad pi_1 = bold("Generalize")(Gamma, tau_1)
          quad Gamma[x mapto pi_1] tstile e_2 : tau_2 rtstile C_2
          ) / (
          Gamma tstile "let" x = e_1 "in" e_2 : tau_2 rtstile C_1 union C_2
          ) \
        & "where" bold("Generalize")(Gamma, tau) =
          forall alpha_1, ..., alpha_n. tau
          and alpha_i in ("free"(tau) - "free"(Gamma))
$
```

### Examples

What type schemes are introduced by the following `let` forms?

- `let id = fun x -> x in ...`

- `let fst = fun x y -> x in ...`

- `fun x -> let f = fun g -> g x in ...`

<!--
`let id = fun x -> x in ...`
- id : forall a. (a -> a)

`let fst = fun x y -> x in ...`
- fst : forall a,b. (a -> b -> a)

`fun x -> let f = fun g -> g x in ...`
- f : forall b. ((a -> b) -> b)
-->

## Instantiation

When looking up a variable, we *instantiate* a monotype from its type scheme

- Replacing every quantified type variable with a fresh one

Intuitively, a type scheme represents a *family of types*. Each time we use it, we create a new member of the family, differing only by the fresh type variable(s).

```typst +render +width:85%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "VAR" & (
          Gamma(x) = pi
          quad tau = bold("Instantiate")(pi)
          )/(
          Gamma tstile x : tau rtstile {}
          ) \
        & "where" bold("Instantiate")(forall alpha_1, ..., alpha_n.tau)
          = ["fresh"(beta_i) \/ alpha_i] tau
$
```

- e.g., `Instantiate`( `‚àÄ Œ±. Œ± ‚Üí Œ±` ) = `Œ≤ ‚Üí Œ≤` (assuming `Œ≤` fresh)

- e.g., `Instantiate`( `‚àÄ Œ±,Œ≤. Œ± ‚Üí Œ≤` ) = `Œ≥ ‚Üí Œ¥` (assuming `Œ≥`, `Œ¥` fresh)

- e.g., `Instantiate`( `‚àÄ Œ±. Œ± ‚Üí Œ≤` ) = `Œ≥ ‚Üí Œ≤` (assuming `Œ≥` fresh)

## The Hindley-Milner Type System

We have now replicated the *Hindley‚ÄìMilner* (HM) type system, which provides a foundation for polymorphic type inference:

- Every well-typed expression has a *principal type scheme* (the most general type)

- Let-generalization and variable instantiation support *parametric polymorphism*

- Type inference can be fully automated, without explicit annotation ("Algorithm W")

HM forms the basis of the type systems in ML, OCaml, Haskell, and many other functional languages

## From Monomorphic Inference to Algorithm W

Our monomorphic type inference worked in two phases:

1. *Collect constraints* for each expression
2. *Unify* the constraints to obtain a substitution

This was possible because:

- Each variable has exactly one type, which never changes
- Constraints don't depend on solving earlier constraints
- Substitutions aren't required during constraint generation

For polymorphic type inference of `let f = e1 in e2`, we must:

- Infer the type of `e1` (obtaining a substitution)
- Apply the resulting substitution to Œì
- Generalize `e1`'s type and infer the type of `e2` in the extended Œì

I.e., we must unify and apply substitutions iteratively

Algorithm W extends monomorphic inference by *combining constraint generation, unification, and polymorphism* into a *single recursive process*.

## Algorithm W: Intuition

To infer the type of an expression `e`:

1. Generate and solve constraints on the fly:
   - Each recursive call returns a *substitution* and a *type*
   - Substitutions are composed as we return upward

2. At `let`-bindings, *generalize*

3. At variable use, *instantiate*

The result: a single pass that *infers types and manages polymorphism* without ever building a separate constraint list.

## Algorithm W: Implementation

```ocaml
let rec infer_expr tenv e =
  match e with
  | Int _ -> (empty_subst, TInt)
  | Bool _ -> (empty_subst, TBool)
  | Var x ->
      let scheme = lookup tenv x in
      (empty_subst, instantiate scheme)
  | Let (x, e1, e2) ->
      let s1, t1 = infer_expr tenv e1 in
      let env1 = apply_subst_env s1 tenv in
      let scheme = generalize env1 t1 in
      let env2 = (x, scheme) :: env1 in
      let s2, t2 = infer_expr env2 e2 in
      let subst = compose_subst s2 s1 in
      (subst, t2)
  ...
```

- the Var rule instantiates the scheme found in the environment
- the Let rule generalizes a scheme from the inferred monotype
- note how (in handling Let), we immediately apply substitutions obtained from recursive calls to types and environments, and we compose the substitutions to return them
- we provide Var, Let, Fun, App (and helper functions) -- you'll need to finish the implementation of Algorithm W!

## Demo

```ocaml
dune utop
# L10_typeinfer.Eval.repl ();;
```

Try our earlier examples!

let id = fun x -> x in id

let id = fun x -> x in id 10

let id = fun x -> x in let a = id 10 in id

let id = fun x -> x in let a = id 10 in id true

## What did we learn?

- Type inference rules generate *constraints* alongside types
- *Type variables* are placeholders for unknown types
- *Unification* produces the most general unifier (MGU)
- *let-generalization* introduces polymorphism via quantification
- The resulting system is the **Hindley‚ÄìMilner type system**
- *Algorithm W* automates it all

Type inference reasons about programs symbolically. *It's a proof system embedded into the compiler*!
