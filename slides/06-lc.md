---
title: "A Lambda Calculus Interpreter"
author: "Michael Lee"
---

# Agenda

- Type Definition
- Some Examples
- Pretty Printer
- Road to an Interpreter
  1. Substitution
  2. Single-Step Reduction
  3. Multi-Step Reduction

---

# Type Definition

We can build a lambda calculus abstract syntax tree (AST) using the following
recursive ADT:

```ocaml
type expr = Var of string
          | Abs of string * expr
          | App of expr * expr
```

---

# Some Examples

```
λx.x = Abs ("x", Var "x")
```

<!-- pause -->

```
λx.λy.x = Abs ("x", Abs ("y", Var "x"))
```

<!-- pause -->

```
λf.λx.f (f x) = Abs ("f",
                     Abs ("x",
                          App (Var "f",
                               App (Var "f",
                                    Var "x"))))
```

<!-- pause -->

```
(λx.x x)(λx.x x) = let w = Abs ("x",
                                App (Var "x",
                                     Var "x"))
                   in App (w, w)
```

---

# Pretty Printer

```ocaml
let string_of_expr (e : expr) : string =
  let rec aux ctx = function
    | Var x -> x
    | Abs (x, e) ->
        let body = aux 0 e in
        let s = Printf.sprintf "λ%s.%s" x body in
        if ctx > 0 then "(" ^ s ^ ")" else s
    | App (e1, e2) ->
        let s = Printf.sprintf "%s %s"
                  (aux 1 e1) (aux 2 e2) in
        if ctx = 2 then "(" ^ s ^ ")" else s
  in aux 0 e
```

---

# Road to an Interpreter

1. Substitution (i.e., [v/x]e)
2. Single-Step Reduction
3. Multi-Step Reduction

---

## 1. Substitution

```ocaml
val subst : expr -> string -> expr -> expr
```

- subsitute expr v for var x in (body) expr t; i.e., [v/x]t

---

## 1. Substitution

Consider (id = Abs ("x", Var "x")):

1. subst id "z" (Var "z") = ?

2. subst id "z" (Var "y") = ?

3. subst id "z" (App (Var "w", Var "z")) = ?

4. subst id "z" (App (Var "z", Var "z")) = ?

5. subst id "z" (Abs ("x", Var "z")) = ?

6. subst id "z" (Abs ("z", Var "z")) = ?

---

## 1. Substitution

```ocaml
let rec subst (v : expr) (x : string) (e : expr) : expr =
  match e with
  | Var y -> if x = y then v else e
  | App (e1, e2) -> App (subst v x e1, subst v x e2)
  (* FIXME: this doesn't handle variable capture! *)
  | Abs (y, body) -> if x = y then e
                     else Abs (y, subst v x body)
```

---

## 2. Single-Step Reduction (Normal-Order)

```ocaml
val step_normal : expr -> expr option
```

- if a redex exists, perform it and return `Some expr`, else return `None`

- recall: normal-order = leftmost/outermost first

---

## 2. Single-Step Reduction (Normal-Order)

Consider:

1. step_normal ( App (id, Var "x") ) = ?

2. step_normal ( App (App (id, id), App (id, id)) ) = ?

3. step_normal ( App (Var "x", App (id, id)) ) = ?

4. step_normal ( Abs ("x", App (id, Var "x")) ) = ?

5. step_normal ( Var "x" ) = ?

6. step_normal ( App (Var "x", Var "y") ) = ?

7. step_normal ( Abs ("x", App (Var "x", Var "y")) ) = ?

---

## 2. Single-Step Reduction (Normal-Order)

```ocaml
let rec step_normal : expr -> expr option = function
  | App (Abs (x, e1), e2) ->
      Some (subst e2 x e1)
  | App (e1, e2) -> (
      match step_normal e1 with
      | Some e1' -> Some (App (e1', e2))
      | None -> (
          match step_normal e2 with
          | Some e2' -> Some (App (e1, e2'))
          | None -> None))
  | Abs (x, e) -> (
       match step_normal e with
       | Some e' -> Some (Abs (x, e'))
       | None -> None)
  | Var _ -> None
```

---

## 3. Multi-Step Reduction (Normal-Order)

```ocaml
let rec eval_normal t =
  match step_normal t with
  | Some t' -> eval_normal t'
  | None -> t
```

- step until no more redexes remain, return resulting expr

  - may get stuck on non-terminating exprs! (e.g., (λx.x x)(λx.x x))

