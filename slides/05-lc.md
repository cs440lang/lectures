---
title: "A Lambda Calculus Interpreter"
author: "Michael Lee"
---

# Agenda

- Type Definition
- Some Examples
- Pretty Printer
- Road to an Interpreter
  1. Substitution
  2. Single-Step Reduction
  3. Multi-Step Reduction

---

# Type Definition

```ocaml
type term = Var of string
          | Abs of string * term
          | App of term * term
```

---

# Some Examples

```
λx.x = Abs ("x", Var "x")
```

<!-- pause -->

```
λx.λy.x = Abs ("x", Abs ("y", (Var "x")))
```

<!-- pause -->

```
λf.λx.f (f x) = Abs ("f",
                     Abs ("x",
                          App (Var "f",
                               App (Var "f",
                                    Var "x"))))
```

<!-- pause -->

```
(λx.x x)(λx.x x) = let w = Abs ("x",
                                App (Var "x",
                                     Var "x"))
                   in App (w, w)
```

---

# Pretty Printer

```ocaml
let pp t =
  let rec aux ctx = function
    | Var x -> x
    | Abs (x, t) ->
        let body = aux 0 t in
        let s = Printf.sprintf "λ%s.%s" x body in
        if ctx > 0 then "(" ^ s ^ ")" else s
    | App (t1, t2) ->
        let s = Printf.sprintf "%s %s" (aux 1 t1) (aux 2 t2) in
        if ctx = 2 then "(" ^ s ^ ")" else s
  in aux 0 t
```

---

# Road to an Interpreter

1. Substitution (i.e., [v/x]t)
2. Single-Step Reduction
3. Multi-Step Reduction

---

## 1. Substitution

```ocaml
val subst : term -> string -> term -> term
```

- subsitute term v for var x in (body) term t; i.e., [v/x]t

---

## 1. Substitution

Consider (id = Abs ("x", Var "x")):

1. subst id "z" (Var "z") = ?

2. subst id "z" (Var "y") = ?

3. subst id "z" (App (Var "w", Var "z")) = ?

4. subst id "z" (App (Var "z", Var "z")) = ?

5. subst id "z" (Abs ("x", Var "z")) = ?

6. subst id "z" (Abs ("z", Var "z")) = ?

---

## 2. Single-Step Reduction (Normal-Order)

```ocaml
val step_normal : term -> term option
```

- if a redex exists, perform it and return `Some term`, else return `None`

- recall: normal-order = leftmost/outermost first

---

## 2. Single-Step Reduction (Normal-Order)

Consider:

1. step_normal ( App (id, Var "x") ) = ?

2. step_normal ( App (App (id, id), App (id, id)) ) = ?

3. step_normal ( App (Var "x", App (id, id)) ) = ?

4. step_normal ( Abs ("x", App (id, Var "x")) ) = ?

5. step_normal ( Var "x" ) = ?

6. step_normal ( App (Var "x", Var "y") ) = ?

7. step_normal ( Abs ("x", App (Var "x", Var "y")) ) = ?

---

## 3. Multi-Step Reduction (Normal-Order)

```ocaml
let rec eval_normal t =
  match step_normal t with
  | Some t' -> eval_normal t'
  | None -> t
```

- step until no more redexes remain, return resulting term

  - may get stuck on non-terminating terms! (e.g., (λx.x x)(λx.x x))
