---
title: "Type Inference"
sub_title: "CS 440: Programming Languages"
author: "Michael Lee"
---

# Agenda

- Type Inference by Example
- Type Variables and Constraints
- Constrained Typing Judgements
- Monomorphic Type Inference Rules
- Solving Constraints with Unification
- Polymorphic Type Inference Rules

---

# From Explicit Type Checking to Type Inference

**Explicit Type Checking**

- Programmer provides *type annotations*.
- System verifies expressions are *consistent* with annotations.

<!-- pause -->

**Type Inference**

- Programmer provides *no* (or few) annotations.
- System infers the *most general type* for each expression.

---

# Inference by Example

How can we infer their types?

- `fun x -> x`

- `fun x -> x + 1`

- `fun f -> fun x -> f x`

- `fun f -> fun x -> f (f x)`

---

# From Examples to Mechanism

To infer types, we:

1. Create *type variables* to represent unknowns
2. Collect *constraints* over those variables
3. *Solve* those constraints to obtain a substitution
4. Apply the *substitution* to get the final inferred type

---

# Type Variables

Type variables are placeholders for unknown types

- May be replaced with other types when solving constraints

- May remain in a final inferred type for polymorphism

<!-- pause -->

We expand our spectrum of types:

```ocaml
type typ = TInt
         | TBool
         | TFun of typ * typ
         | TVar of type_var
```

---

# Creating "Fresh" Type Variables

When introducing a new type variable, it must be *fresh* -- i.e., it cannot be
used/constrained elsewhere in the environment. (Why?)

<!-- pause -->

In our code, we do this by simply making `type_vars` sequential `int`s.

```ocaml
type type_var = int

let fresh_int =
  let counter = ref 0 in
  fun () ->
    let v = !counter in
    incr counter;
    v

let fresh_var () = TVar (fresh_int ())
```

---

# Constraints

A constraint is an equation between types.

E.g., `bool` = `bool`; `…ë` = `int`; `Œ≤‚Üí int` = `bool‚Üí …£`

<!-- pause -->

We can represent this as:

```ocaml
type type_constraint = typ * typ
```

---

# Constrained Typing Judgements

We update our typing judgement to:

```typst +render +width:40%
#let tstile = sym.tack.r
#let rtstile = sym.tack.l
$
Gamma tstile e : tau rtstile C
$
```

I.e., `e` has type `œÑ` under `Œì` iff all constraints in `C` are satisfiable.

---

# Collecting Constraints

Our first goal is to recursively collect constraints for an expression:

```ocaml
val collect_constraints :
  type_env -> expr -> typ * type_constraint list
```

---

# Type Inference Rules

<!-- pause -->

## Values

<!-- pause -->

```typst +render +width:60%
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
"INT" & () / (Gamma tstile i in ZZ : "int" rtstile {}) \
     \
"BOOL" & () / (Gamma tstile b in {"true", "false"} : "bool" rtstile {}) \
$
```

No constraints are generated by these rules.

<!-- pause -->

```ocaml
let rec collect_constraints tenv e =
  match e with
  | Int _ ->  (TInt, [])
  | Bool _ -> (TBool, [])
```

---

# Type Inference Rules

## Variables

```typst +render +width:30%
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
"VAR" & (Gamma(x) = tau) / (Gamma tstile x : tau rtstile {}) 
$
```

```ocaml
| Var x -> (lookup tenv x, [])
```

---

# Type Inference Rules

## Binary Operators

```typst +render +width:80%
#let bop = sym.plus.o
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
 "BOP-I" & (bop in {+,*}
           quad Gamma tstile e_1 : tau_1 rtstile C_1
           quad Gamma tstile e_2 : tau_2 rtstile C_2)
           / (Gamma tstile e_1 bop e_2 : "int"
           rtstile C_1 union C_2
           union { tau_1 = "int", tau_2 = "int"}) \
         \
 "BOP-B" & (quad Gamma tstile e_1 : tau_1 rtstile C_1
           quad Gamma tstile e_2 : tau_2 rtstile C_2)
           / (Gamma tstile e_1 <= e_2 : "bool"
           rtstile C_1 union C_2
           union { tau_1 = "int", tau_2 = "int"}) \
$
```

The `BOP` rules constrain their operands to be of type `int`.

---

# Type Inference Rules

## Binary Operators

```ocaml
| Binop (bop, e1, e2) -> (
    let t1, c1 = collect_constraints tenv e1 in
    let t2, c2 = collect_constraints tenv e2 in
    match bop with
    | Add | Mult ->
        (TInt, c1 @ c2 @ [ (t1, TInt); (t2, TInt) ])
    | Leq ->
        (TBool, c1 @ c2 @ [ (t1, TInt); (t2, TInt) ]))
```

---

# Type Inference Rules

## `if-then-else`

<!-- pause -->

```typst +render +width:100%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "IF" & ("fresh" alpha
         quad Gamma tstile e_1 : tau_1 rtstile C_1
         quad Gamma tstile e_2 : tau_2 rtstile C_2
         quad Gamma tstile e_3 : tau_3 rtstile C_3)
         / (Gamma tstile "if" e_1 "then" e_2 "else" e_3 : alpha
         rtstile C_1 union C_2 union C_3
         union { tau_1 = "bool", alpha=tau_2, alpha=tau_3}) \
$
```

<!-- pause -->

```ocaml
| If (e1, e2, e3) ->
    let t = fresh_var () in
    let t1, c1 = collect_constraints tenv e1 in
    let t2, c2 = collect_constraints tenv e2 in
    let t3, c3 = collect_constraints tenv e3 in
    (t, c1 @ c2 @ c3 @ [ (t1, TBool); (t, t2); (t, t3) ])
```

---

# Demo

```ocaml
dune utop
# L10_typeinfer.Mono_typeinfer.repl ();;
```

<!-- pause -->

What constraints do the following generate?

- `1 + 2`
- `1 + true`
- `if 1 then 2 else 3`
- `if 1 <= true then 2 else false`

---

# Type Inference Rules

## `let`

<!-- pause -->

```typst +render +width:80%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "LET" & (
          Gamma tstile e_1 : tau_1 rtstile C_1
          quad
          Gamma[x mapto tau_1] tstile e_2 : tau_2 rtstile C_2
          )/(
          Gamma tstile "let" x = e_1 "in" e_2 : tau_2 rtstile C_1 union C_2
          )
$
```

<!-- pause -->

```ocaml
| Let (x, e1, e2) ->
    let t1, c1 = collect_constraints tenv e1 in
    let tenv' = (x, t1) :: tenv
    let t2, c2 = collect_constraints tenv' e2 in
    (t2, c1 @ c2)
```

---

# Type Inference Rules

## `fun`

<!-- pause -->

```typst +render +width:70%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
   "FUN" & ("fresh" alpha
           quad Gamma[x mapto alpha] tstile e : tau rtstile C)
           / (Gamma tstile "fun" x "->" e : alpha -> tau
           rtstile C) \
$
```

<!-- pause -->

```ocaml
| Fun (x, e) ->
    let tx = fresh_var () in
    let tenv' = (x, tx) :: tenv in
    let te, ce = collect_constraints tenv' e in
    (TFun (tx, te), ce)
```

---

# Type Inference Rules

## Application

<!-- pause -->

```typst +render +width:80%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
 "APP" & ("fresh" alpha
         quad Gamma tstile e_1 : tau_1 rtstile C_1
         quad Gamma tstile e_2 : tau_2 rtstile C_2)
         / (Gamma tstile e_1 e_2 : alpha rtstile C_1 union C_2
         union { tau_1 = tau_2 -> alpha}) 
$
```

<!-- pause -->

```ocaml
| App (e1, e2) ->
    let t = fresh_var () in
    let t1, c1 = collect_constraints_expr tenv e1 in
    let t2, c2 = collect_constraints_expr tenv e2 in
    (t, c1 @ c2 @ [ (t1, TFun (t2, t)) ])
```

---

# Demo

```ocaml
dune utop
# L10_typeinfer.Mono_typeinfer.repl ();;
```

What constraints do the following generate?

- `fun x -> x`
- `fun x -> x + 1`
- `fun f -> fun x -> f x`
- `(fun x -> x) 10`

---

# Solving Constraints

**Goal:** find a *substitution* `S` such that `S`(`œÑ‚ÇÅ`) = `S`(`œÑ‚ÇÇ`) for every
constraint `œÑ‚ÇÅ` = `œÑ‚ÇÇ`.

- Where a substitution maps type variables to types

  - i.e., `S` = { `Œ±‚ÇÅ ‚Ü¶ œÑ‚ÇÅ`, `…ë‚ÇÇ ‚Ü¶ œÑ‚ÇÇ`, ..., `…ë‚Çô ‚Ü¶ œÑ‚Çô` }

<!-- pause -->

- Applying substitution `S` to type `œÑ` (i.e., `S`(`œÑ`)) replaces type variables
  in `œÑ` based on the mappings

  - e.g., given `S` = { `…ë ‚Ü¶ int`, `Œ≤ ‚Ü¶ bool` }

    - `S`(`…ë ‚Üí  Œ≤`) = `int ‚Üí bool`

<!-- pause -->

*Unification* is an algorithm that solves this problem.

---

# Unification Rules

<!-- incremental_lists: true -->

1. `Unify`(`œÑ`, `œÑ`) = {}

2. `Unify`(`Œ±`, `œÑ`) or `Unify`(`œÑ`, `Œ±`) = { `Œ± ‚Ü¶ œÑ` } if `Œ±` ‚àâ free(`œÑ`)

   - if `Œ±` ‚àà free(`œÑ`), "infinite type" failure

3. `Unify`(`œÑ1 ‚Üí œÑ2`, `œÑ3 ‚Üí œÑ4`) = `S2` ‚àò `S1`

   - where `S1` = `Unify`(`œÑ1`, `œÑ3`)

   - and `S2` = `Unify`(`S1`(`œÑ2`), `S1`(`œÑ4`))

4. Otherwise: incompatible types failure

<!--
speaker_note: |

  The requirement that `Œ±` ‚àâ free(`œÑ`) prevents "infinite types"

  - e.g., the constraint Œ± = Œ± -> int

  Rule 3 introduces the idea of *composing* substitutions
-->

---

# Applying Unification

To solve a list of constraints {`œÑ‚ÇÅ` = `œÑ‚ÇÇ`, ... },

<!-- incremental_lists: true -->

1. Unify each in turn, producing a substitution `S`

2. Apply `S` to remaining constraints and the accumulated substitution

3. Continue until all constraints are processed or failure

If unification completes, it yields the *most general unifier* (MGU): the
substitution that solves all constraints without being overly specific.

- Intuition: `fun x -> x` should have type `Œ± ‚Üí Œ±`, not `int ‚Üí int`

---

# Sample Unification Problems

Find the MGU for each constraint set, or explain why unification fails.

<!-- column_layout: [1, 1, 1] -->

<!-- column: 0 -->

(1)

`…ë` = `bool`

`Œ≤` = `…ë`

<!-- new_line -->

(4)

`…ë` ‚Üí `Œ≤` = `bool` ‚Üí `int`

`…ë` = `int`

<!-- column: 1 -->

(2)

`…ë` ‚Üí `int` = `bool` ‚Üí `Œ≤`

<!-- new_lines: 3 -->

(5)

`…ë` = `Œ≤` ‚Üí `…£`

`Œ≤` = `…£` ‚Üí `int`

`…ë` = `ùõÖ` ‚Üí `Œµ`

<!-- column: 2 -->

(3)

`…ë` = `Œ≤` ‚Üí `…£`

`…ë` = `int` ‚Üí `bool`

<!-- new_line -->

(6)

`…ë` = `Œ≤` ‚Üí `int`

`Œ≤` = `…ë`

<!--
speaker_note: |

  Remember that you can check your substitutions by running them on the
  constraints!

-->

---

# Implementing Unification

```ocaml
type substitution = (type_var * typ) list

let rec unify (t1 : typ) (t2 : typ) : substitution =
  match (t1, t2) with
  | TInt, TInt   -> []
  | TBool, TBool -> []
  | TVar v, ty | ty, TVar v ->
      [ (v, ty) ] (* check for infinite type *)
  | TFun (a1, b1), TFun (a2, b2) ->
      let s1 = unify a1 a2 in
      let b1' = apply_subst s1 b1 in
      let b2' = apply_subst s1 b2 in
      let s2 = unify b1' b2' in
      compose_subst s2 s1
  | _ -> raise (TypeError "Incompatible types")
```

---

# The Problem with Let

What types do we infer for the following?

```ocaml
let id = fun x -> x in id

let id = fun x -> x in id 10

let id = fun x -> x in let a = id 10 in id

let id = fun x -> x in let a = id 10 in id true
```

---

# Monomorphic vs. Polymorphic Type Inference

---

# Introducing Type Schemes

A **type scheme** represents polymorphic types:

```
œÄ ::= ‚àÄ Œ±‚ÇÅ ... Œ±‚Çô. œÑ
```

Free type variables of `œÑ` not appearing in Œì are *generalized*.

Instantiation replaces quantified variables with fresh ones.

---

# Instantiation (Updated `VAR`)

We instantiate a *monotype* from the type scheme on variable lookup.

```typst +render +width:85%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "VAR" & (
          Gamma(x) = pi
          quad tau = bold("Instantiate")(pi)
          )/(
          Gamma tstile x : tau rtstile {}
          ) \
        & "where" bold("Instantiate")(forall alpha_1, ..., alpha_n.tau)
          = ["fresh"(beta_i) \/ alpha_i] tau
$
```

---

# Generalization (Updated `LET`)

We generalize a type scheme from an inferred monotype and bind it to the
variable in the environment.

```typst +render +width:100%
#let mapto = sym.arrow.r.bar
#let tstile = sym.tack.r
#let rtstile = sym.tack.l

$
  "LET" & (
          Gamma tstile e_1 : tau_1 rtstile C_1
          quad pi_1 = bold("Generalize")(Gamma, tau_1)
          quad Gamma[x mapto pi_1] tstile e_2 : tau_2 rtstile C_2
          ) / (
          Gamma tstile "let" x = e_1 "in" e_2 : tau_2 rtstile C_1 union C_2
          ) \
        & "where" bold("Generalize")(Gamma, tau) =
          forall alpha_1, ..., alpha_n. tau
          and alpha_i in ("free"(tau) - "free"(Gamma))
$
```

---

# The Hindley-Milner Type System

We have arrived at the Hindley‚ÄìMilner (HM) type system, which provides a
foundation for polymorphic type inference:

- each well-typed expression has a principal type scheme (the most general
  type).

- type inference can be fully automated, without explicit annotation ("Algorithm
  W")

<!-- pause -->

HM forms the basis of the type systems in ML, OCaml, Haskell, and many other
functional languages.

---

# Algorithm W Overview

Algorithm W performs *type inference with let-polymorphism* recursively.
